---
title: 'Version Control With Git'
date: 2020-12-28
permalink: /posts/2020/12/blog-post-1/
tags:
  - VCS
  - Git
  - Distributed Version Control Systems
---
What is a Version Control System
======
Version control systems (VCSs) are tools used to track changes to source code (or other collections of files and folders). As the name implies, these tools help maintain a history of changes; furthermore, they facilitate collaboration. VCSs track changes to a folder and its contents in a series of snapshots, where each snapshot captures the entire state of files/folders within a top-level directory. VCSs also maintain metadata like who created each snapshot, messages associated with each snapshot, and so on.


Why use Version Control Systems
======
Why is version control useful? Even when you’re working by yourself, it can let you look at old snapshots of a project, keep a log of why certain changes were made, work on parallel branches of development, and much more. When working with others, it’s an invaluable tool for seeing what other people have changed, as well as resolving conflicts in concurrent development.

Modern VCSs also let you easily (and often automatically) answer questions like:
  - Who wrote this module?
  - When was this particular line of this particular file edited? By whom? Why was it edited?
  - Over the last 1000 revisions, when/why did a particular unit test stop working?

While other VCSs exist, <b>Git</b> is the de facto standard for version control.
Because Git’s interface is a <b>leaky</b> abstraction, learning Git top-down (starting with its interface / command-line interface) can lead to a lot of confusion. It’s possible to memorize a handful of commands and think of them as magic incantations, and guess whenever anything goes wrong.

While Git admittedly has an ugly interface, its underlying design and ideas are beautiful. While an ugly interface has to be memorized, a beautiful design can be understood. For this reason, we give a bottom-up explanation of Git, starting with its data model and later covering the command-line interface. Once the data model is understood, the commands can be better understood, in terms of how they manipulate the underlying data model.

Data Model of Git
======
There are many ad-hoc approaches you could take to version control. Git has a well thought-out model that enables all the nice features of version control, like maintaining history, supporting branches, and enabling collaboration.

<b>Snapshots</b><br />
Git models the history of a collection of files and folders within some top-level directory as a series of snapshots. In Git terminology, a file is called a “blob”, and it’s just a bunch of bytes. A directory is called a “tree”, and it maps names to blobs or trees (so directories can contain other directories). A snapshot is the top-level tree that is being tracked. For example, we might have a tree as follows:
![vcs_001.png](http://yusufbrima.github.io/images/vcs_001.png)

The top-level tree contains two elements, a tree “foo” (that itself contains one element, a blob “bar.txt”), and a blob “baz.txt”.

<b>Modeling history: relating snapshots</b><br />
How should a version control system relate snapshots? One simple model would be to have a linear history. A history would be a list of snapshots in time-order. For many reasons, Git doesn’t use a simple model like this.

In Git, a history is a directed acyclic graph (DAG) of snapshots. That may sound like a fancy math word, but don’t be intimidated. All this means is that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. It’s a set of parents rather than a single parent (as would be the case in a linear history) because a snapshot might descend from multiple parents, for example due to combining (merging) two parallel branches of development.

Git calls these snapshots “commit”s. Visualizing a commit history might look something like this:
![vcs_002.png](http://yusufbrima.github.io/images/vcs_002.png)

In the ASCII art above, the os correspond to individual commits (snapshots). The arrows point to the parent of each commit (it’s a “comes before” relation, not “comes after”). After the third commit, the history branches into two separate branches. This might correspond to, for example, two separate features being developed in parallel, independently from each other. In the future, these branches may be merged to create a new snapshot that incorporates both of the features, producing a new history that looks like this, with the newly created merge commit shown in bold:
![vcs_003.png](http://yusufbrima.github.io/images/vcs_003.png)
Commits in Git are immutable. This doesn’t mean that mistakes can’t be corrected, however; it’s just that “edits” to the commit history are actually creating entirely new commits, and references (see below) are updated to point to the new ones.

<b>Data model, as pseudocode</b><br />
It may be instructive to see Git’s data model written down in pseudocode:
![vcs_004.png](http://yusufbrima.github.io/images/vcs_004.png)

It’s a clean, simple model of history.
<b>Objects and content-addressing</b><br />
An “object” is a blob, tree, or commit:
![vcs_005.png](http://yusufbrima.github.io/images/vcs_005.png)

In Git data store, all objects are content-addressed by their <a href="https://en.wikipedia.org/wiki/SHA-1" target="_blank">SHA-1 hash</a>.
![vcs_006.png](http://yusufbrima.github.io/images/vcs_006.png)
Blobs, trees, and commits are unified in this way: they are all objects. When they reference other objects, they don’t actually contain them in their on-disk representation, but have a reference to them by their hash.

For example, the tree for the example directory structure above (visualized using git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d), looks like this:
![vcs_007.png](http://yusufbrima.github.io/images/vcs_007.png)

The tree itself contains pointers to its contents, baz.txt (a blob) and foo (a tree). If we look at the contents addressed by the hash corresponding to baz.txt with git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85.

<b>References</b><br />
Now, all snapshots can be identified by their SHA-1 hash. That’s inconvenient, because humans aren’t good at remembering strings of 40 hexadecimal characters.

Git’s solution to this problem is human-readable names for SHA-1 hashes, called “references”. References are pointers to commits. Unlike objects, which are immutable, references are mutable (can be updated to point to a new commit). For example, the master reference usually points to the latest commit in the main branch of development.
![vcs_008.png](http://yusufbrima.github.io/images/vcs_008.png)


References
======
